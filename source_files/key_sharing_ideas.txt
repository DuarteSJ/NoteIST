note: ownerId, id, version
user has a pending keys attribute as follows:

[
  {
    ownerID: ""
    id: ""
    secret: ""  
  },
  {
    ownerID: ""
    id: ""
    secret: ""
  }
]

remove user: # TODO: decide if user looses access to previous versions or not
  - owner removes user
  - owner generates new key
  - owner rencripts note with new key
  - owner shares new key with all remaining editors/viewers

{
    "type": "ADD_COLABORATOR",
    "data": {
        "note_id":
        "editorFlag": True/False,
        "collaborator_username":
    }
}

push:
  actions:[
    dict1,
    dict2,
    ...,
    dict n
  ],
  removes: (username, id)
    [usernames]
  adds:
    [usernames]

pushResponse:
  actionsResponse:[respostas]
  removesAndAddsResponse:[
    if removes is empty:
      public key of new added users
    else:
      public key of all remaining users
  ]


                #there will be the need for a final push to give the server the key encrypted
                #with the public key of the added users
                # {
                #       "note_id": [
                #           {
                #               user_id: user_id,
                #               public_key: public key,
                #           },
                #           {   
                #               user_id: user_id,
                #               public_key: public key,
                #           },
                #           ...
                #       ],
                #       "note_id2": [
                #           {
                #               user_id: user_id,
                #               public_key: public key,
                #           },
                #           {
                #               user_id: user_id,
                #               public_key: public key,
                #           },
                #           ...
                #       ],
                #      ...
                # }